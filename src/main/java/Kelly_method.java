public class Kelly_method {    private final static double[] constraints_Matrix_Addition = {-1, -1};    private final static double[] constraints_Matrix_Artificial = {1, 1};    private final static double[] vector_Right_Part = {1, 1};    private final static int number_of_args = 2;    private final static int original_number_of_constraints = 2;    public static void main(String[] args) {        double eps = 0.01;        double[] first_compact = {4, 3};        double[][] start_matrix_constraints = {{1, 0}, {0, 1}};        double[] optimum_solution = {4, 3};        double[] previous_compact = first_compact;        double[] previous_optimum_solution = {5, 4};        int number_of_constraints = start_matrix_constraints.length;        int j_constraints = number_of_constraints;        int size_of_function = number_of_constraints + constraints_Matrix_Addition.length;        Keep_matrix keeper = new Keep_matrix(start_matrix_constraints);        while (Method_for_Kelly.norma(previous_optimum_solution, optimum_solution) > eps) {            size_of_function++;            j_constraints++;            int index = Method_for_Kelly.find_the_most_close_constraint(original_number_of_constraints, optimum_solution);            double[] originalVectorFunction = new double[size_of_function];            double[] vectorFunction = new double[size_of_function + constraints_Matrix_Artificial.length];            double[] new_constraint = Method_for_Kelly.create_new_constraint(index, number_of_args, optimum_solution);            double[][] constraintsMatrix = Method_for_Kelly.make_new_constraints_matrix(keeper.matrix, new_constraint);            keeper.matrix = constraintsMatrix;            Method_for_Kelly.show_vector(new_constraint);            number_of_constraints++;            double[] original_right_part = new double[number_of_constraints];            for (int i = 0 ; i < number_of_constraints ; i++) {                if (i == number_of_constraints - 1) {                    original_right_part[i] = -new_constraint[new_constraint.length - 1];                    break;                }                original_right_part[i] = previous_compact[i];            }            for (int i = 0 ; i < originalVectorFunction.length ; i++) {                if (i < number_of_constraints) {                    originalVectorFunction[i] = -original_right_part[i];                } else                    originalVectorFunction[i] = 0;            }            for (int i = 0 ; i < vectorFunction.length ; i++) {                if (i < size_of_function)                    vectorFunction[i] = 0;                else                    vectorFunction[i] = -1;            }            double[] result = Simplex_method.simplex_method(vectorFunction,                    originalVectorFunction,                    constraintsMatrix,                    constraints_Matrix_Addition,                    constraints_Matrix_Artificial,                    vector_Right_Part);            for (int i = 0 ; i < optimum_solution.length ; i++) {                previous_optimum_solution[i] = optimum_solution[i];            }            for (int i = 0 ; i < optimum_solution.length ; i++) {                optimum_solution[i] = result[i];            }            previous_compact = original_right_part;            Method_for_Kelly.show_vector(vectorFunction);            Method_for_Kelly.show_vector(originalVectorFunction);            Method_for_Kelly.show_matrix(keeper.matrix);            Method_for_Kelly.show_vector(result);        }    }}class Keep_matrix {    double[][] matrix;    Keep_matrix(double[][] matrix) {        this.matrix = matrix;    }}class Method_for_Kelly {    static double[][] make_new_constraints_matrix(double[][] old_matrix, double[] add_vector) {        double[][] new_matrix = new double[old_matrix.length][old_matrix[0].length + 1];        for (int i = 0 ; i < new_matrix.length ; i++) {            for (int j = 0 ; j < new_matrix[0].length ; j++) {                if (j < old_matrix[0].length)                    new_matrix[i][j] = old_matrix[i][j];                else                    new_matrix[i][j] = -add_vector[i];            }        }        return new_matrix;    }    private static double right_part(int index, double[] coef, Function function, double[] val) {        double res = 0;        for (int i = 0 ; i < coef.length - 1 ; i++) {            res += coef[i] * val[i];        }        return -function.look_for_max_constraint(index, val[0], val[1]) + res;    }    static double[] create_new_constraint(int index, int number_of_args, double val[]) {        Function function = new Function();        double[] coefficients = new double[number_of_args + 1];        Vector gradient = new Vector();        function.take_gradient(index, gradient, val[0], val[1]);        coefficients[0] = gradient.comp1; //FIX!!!!!!        coefficients[1] = gradient.comp2;        coefficients[2] = right_part(index, coefficients, function, val);        return coefficients;    }    static int find_the_most_close_constraint(int number_of_constraints, double[] val) {        int index = 0;        double value = 0;        double curr;        Function function = new Function();        for (int j = 0 ; j < number_of_constraints ; j++) {            curr = Math.max(-function.look_for_max_constraint(j, val[0], val[1]), 0);            if (curr > value) {                value = curr;                index = j;            }        }        return index;    }    static void show_vector(double[] vector) {        for (int i = 0 ; i < vector.length ; i++) {            System.out.print(vector[i] + " ");        }        System.out.println();    }    static void show_matrix(double[][] matrix) {        for (int i = 0 ; i < matrix.length ; i++) {            for (int j = 0 ; j < matrix[i].length ; j++) {                System.out.print(String.format("%.2f ", matrix[i][j]));            }            System.out.println();        }        System.out.println();    }    static double norma(double[] vector1, double[] vector2) {        double norma = 0;        for (int i = 0 ; i < vector1.length ; i++) {            norma += Math.pow(vector1[i] - vector2[i], 2);        }        return Math.sqrt(norma);    }}class Function {    interface My_functions {        double next_func(double x1, double x2);    }    interface My_gradient {        Vector next_grad(Vector gradient, double x1, double x2);    }    My_functions[] my_functions = new My_functions[]{            new My_functions() {                public double next_func(double x1, double x2) { return constrait_1(x1, x2); }            },            new My_functions() {                public double next_func(double x1, double x2) { return constrait_2(x1, x2); }            }    };    My_gradient[] my_gradients = new My_gradient[]{            new My_gradient() {                public Vector next_grad(Vector gradient, double x1, double x2) { return gradient_1(gradient, x1, x2); }            },            new My_gradient() {                public Vector next_grad(Vector gradient, double x1, double x2) { return gradient_2(gradient, x1, x2); }            }    };    double look_for_max_constraint(int index, double x1, double x2) {        return my_functions[index].next_func(x1, x2);    }    void take_gradient(int index, Vector gradient, double x1, double x2) {        my_gradients[index].next_grad(gradient, x1, x2);    }    public static double main_function(double x1, double x2) {        return x1 + x2;    }    static double constrait_1(double x1, double x2) {        return +2 * x1 - Math.pow(x2, 2) - 1;    }    static double constrait_2(double x1, double x2) {        return -0.8 * Math.pow(x1, 2) - 2 * x2 + 9;    }    static Vector gradient_1(Vector gradient, double x1, double x2) {        gradient.comp1 = 2;        gradient.comp2 = -2 * x2;        return gradient;    }    static Vector gradient_2(Vector gradient, double x1, double x2) {        gradient.comp1 = -1.6 * x1;        gradient.comp2 = -2;        return gradient;    }}class Vector {    double comp1;    double comp2;}